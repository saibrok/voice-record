<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1"
    />
    <title>Browser Voice Recorder (no backend)</title>
    <style>
      :root {
        --bg: #0f1115;
        --panel: #151a22;
        --panel2: #10141b;
        --text: #e8edf5;
        --muted: #a7b2c6;
        --accent: #8cffb3;
        --warn: #ffd36b;
        --danger: #ff6b6b;
        --border: #273043;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial, 'Noto Sans',
          'Apple Color Emoji', 'Segoe UI Emoji';
        background: radial-gradient(900px 500px at 20% 0%, #1a2240 0%, transparent 70%),
          radial-gradient(800px 500px at 90% 10%, #243a2a 0%, transparent 60%), var(--bg);
        color: var(--text);
      }
      .wrap {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
      }
      h1 {
        font-size: 18px;
        margin: 0 0 10px;
        font-weight: 650;
        letter-spacing: 0.2px;
      }
      .grid {
        display: grid;
        grid-template-columns: 620px 1fr;
        gap: 14px;
        align-items: start;
      }
      @media (max-width: 980px) {
        .grid {
          grid-template-columns: 1fr;
        }
      }

      .card {
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.03), rgba(255, 255, 255, 0.01));
        border: 1px solid var(--border);
        border-radius: 14px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.25);
        overflow: hidden;
      }
      .card .hd {
        padding: 14px 14px 10px;
        border-bottom: 1px solid rgba(39, 48, 67, 0.7);
        background: rgba(16, 20, 27, 0.35);
      }
      .card .bd {
        padding: 14px;
      }
      .row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      .row3 {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 10px;
      }
      .field {
        display: grid;
        gap: 6px;
      }
      label {
        font-size: 12px;
        color: var(--muted);
      }
      select,
      input[type='number'],
      input[type='text'] {
        width: 100%;
        padding: 10px 10px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: rgba(16, 20, 27, 0.85);
        color: var(--text);
        outline: none;
      }
      input[type='range'] {
        width: 100%;
      }
      .hint {
        font-size: 12px;
        color: var(--muted);
        line-height: 1.35;
      }
      .pill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid rgba(39, 48, 67, 0.9);
        background: rgba(16, 20, 27, 0.55);
        font-size: 12px;
        color: var(--muted);
      }
      .pill b {
        color: var(--text);
        font-weight: 650;
      }
      .actions {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 10px;
      }
      button {
        appearance: none;
        border: 1px solid var(--border);
        background: rgba(16, 20, 27, 0.75);
        color: var(--text);
        padding: 10px 12px;
        border-radius: 12px;
        cursor: pointer;
        font-weight: 650;
        letter-spacing: 0.2px;
      }
      button.primary {
        border-color: rgba(140, 255, 179, 0.45);
        box-shadow: 0 0 0 3px rgba(140, 255, 179, 0.08);
      }
      button.danger {
        border-color: rgba(255, 107, 107, 0.45);
        box-shadow: 0 0 0 3px rgba(255, 107, 107, 0.08);
      }
      button:disabled {
        opacity: 0.55;
        cursor: not-allowed;
      }

      .canvasWrap {
        padding: 14px;
      }
      canvas {
        width: 100%;
        height: 220px;
        background: rgba(16, 20, 27, 0.65);
        border: 1px solid var(--border);
        border-radius: 14px;
        display: block;
      }
      .timeline {
        display: grid;
        gap: 10px;
        margin-top: 12px;
      }
      .kpi {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }
      .kpi .pill {
        user-select: none;
      }

      .msg {
        margin-top: 10px;
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: rgba(16, 20, 27, 0.55);
        color: var(--muted);
        font-size: 13px;
      }
      .msg.warn {
        border-color: rgba(255, 211, 107, 0.45);
        color: #ffe7b0;
      }
      .msg.bad {
        border-color: rgba(255, 107, 107, 0.45);
        color: #ffd0d0;
      }
      .mono {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
        font-size: 12px;
      }
      .small {
        font-size: 12px;
        color: var(--muted);
      }
      a {
        color: var(--accent);
        text-decoration: none;
      }
      a:hover {
        text-decoration: underline;
      }
    </style>
  </head>

  <body>
    <div class="wrap">
      <h1>
        Запись аудио в браузере (без бэкенда): выбор устройства, визуализация, базовое редактирование (trim/cut),
        экспорт WAV
      </h1>

      <div class="grid">
        <section class="card">
          <div class="hd">
            <div class="kpi">
              <span class="pill">Статус: <b id="status">не инициализировано</b></span>
              <span class="pill">Sample rate: <b id="sr">—</b></span>
              <span class="pill">Каналы: <b id="ch">—</b></span>
              <span class="pill">Длина: <b id="dur">—</b></span>
            </div>
          </div>

          <div class="bd">
            <div class="field">
              <label for="deviceSelect">Устройство ввода (микрофон)</label>
              <select id="deviceSelect"></select>
              <div class="hint">
                Список устройств появляется корректно после первого разрешения на доступ к микрофону.
              </div>
            </div>

            <div
              class="row"
              style="margin-top: 10px"
            >
              <div class="field">
                <label for="preferSR">Желаемая частота (Hz)</label>
                <select id="preferSR">
                  <option value="">По умолчанию устройства</option>
                  <option value="8000">8000</option>
                  <option value="16000">16000</option>
                  <option value="22050">22050</option>
                  <option value="32000">32000</option>
                  <option value="44100">44100</option>
                  <option value="48000" selected>48000</option>
                  <option value="96000">96000</option>
                </select>
                <div class="hint">Фактическая частота зависит от устройства/ОС/браузера; будет показана сверху.</div>
              </div>
              <div class="field">
                <label for="channels">Каналы</label>
                <select id="channels">
                  <option
                    value="1"
                    selected
                  >
                    Mono (1)
                  </option>
                  <option value="2">Stereo (2)</option>
                </select>
                <div class="hint">Для дикторской записи обычно предпочтительнее Mono.</div>
              </div>
            </div>

            <div
              class="row"
              style="margin-top: 10px"
            >
              <div class="field">
                <label>DSP в getUserMedia</label>
                <div class="hint">
                  <label class="small"
                    ><input
                      type="checkbox"
                      id="ec"
                      checked
                    />
                    Echo cancellation</label
                  ><br />
                  <label class="small"
                    ><input
                      type="checkbox"
                      id="ns"
                      checked
                    />
                    Noise suppression</label
                  ><br />
                  <label class="small"
                    ><input
                      type="checkbox"
                      id="agc"
                      checked
                    />
                    Auto gain control</label
                  >
                </div>
                <div class="hint">
                  Для диктора обычно лучше выключать EC/NS/AGC (сохраняет естественность и динамику), но это зависит от
                  условий комнаты.
                </div>
              </div>
              <div class="field">
                <label for="mime">Кодек записи</label>
                <select id="mime"></select>
                <div class="hint">
                  Запись идёт в поддерживаемый браузером формат (часто Opus), затем можно экспортировать в WAV (PCM).
                </div>
              </div>
            </div>

            <div class="actions">
              <button
                id="btnInit"
                class="primary"
              >
                1) Инициализировать микрофон
              </button>
              <button
                id="btnDisable"
                disabled
              >
                Отключить микрофон
              </button>
              <button
                id="btnStart"
                class="primary"
                disabled
              >
                2) Начать запись
              </button>
              <button
                id="btnStop"
                class="danger"
                disabled
              >
                Остановить
              </button>
              <button
                id="btnClear"
                disabled
              >
                Сбросить
              </button>
            </div>

            <div
              id="compat"
              class="msg warn"
              style="display: none"
            ></div>
            <div
              id="log"
              class="msg mono"
              style="display: none"
            ></div>
          </div>
        </section>

        <section class="card">
          <div class="hd">
            <div class="kpi">
              <span class="pill">Визуализация: <b id="vizMode">live</b></span>
              <span class="pill">In: <b id="inLabel">0.00s</b></span>
              <span class="pill">Out: <b id="outLabel">0.00s</b></span>
            </div>
          </div>

          <div class="canvasWrap">
            <canvas
              id="scope"
              width="1200"
              height="240"
            ></canvas>

            <div class="timeline">
              <div class="row">
                <div class="field">
                  <label for="inPoint">In (сек)</label>
                  <input
                    id="inPoint"
                    type="range"
                    min="0"
                    max="0"
                    step="0.01"
                    value="0"
                    disabled
                  />
                </div>
                <div class="field">
                  <label for="outPoint">Out (сек)</label>
                  <input
                    id="outPoint"
                    type="range"
                    min="0"
                    max="0"
                    step="0.01"
                    value="0"
                    disabled
                  />
                </div>
              </div>

              <div class="actions">
                <button
                  id="btnPlay"
                  disabled
                >
                  Прослушать
                </button>
                <button
                  id="btnExportWav"
                  class="primary"
                  disabled
                >
                  Скачать WAV (Trim In/Out)
                </button>
                <button
                  id="btnCut"
                  disabled
                >
                  Вырезать выделение (Cut) и заменить запись
                </button>
              </div>

              <div class="hint">
                Редактирование здесь намеренно минимальное: In/Out для trim, и один cut-сегмент (удалить выделение и
                «склеить» остальное). Для сложного монтажа лучше экспорт в WAV и работа в Audition/Reaper.
              </div>

              <audio
                id="player"
                controls
                style="width: 100%; display: none; margin-top: 8px"
              ></audio>
            </div>
          </div>
        </section>
      </div>

      <div class="msg">
        Примечания по качеству:
        <ul>
          <li>Микрофон/предусилитель/комната влияют сильнее всего.</li>
          <li>Для диктора обычно: Mono, 48 kHz, EC/NS/AGC выключены, пик громкости около -6 dBFS (без клиппинга).</li>
          <li>Браузер пишет через MediaRecorder (часто Opus). Экспорт WAV здесь делает PCM 16-bit.</li>
        </ul>
      </div>
    </div>

    <script>
      (() => {
        // ---------- DOM ----------
        const els = {
          status: document.getElementById('status'),
          sr: document.getElementById('sr'),
          ch: document.getElementById('ch'),
          dur: document.getElementById('dur'),
          deviceSelect: document.getElementById('deviceSelect'),
          preferSR: document.getElementById('preferSR'),
          channels: document.getElementById('channels'),
          ec: document.getElementById('ec'),
          ns: document.getElementById('ns'),
          agc: document.getElementById('agc'),
          mime: document.getElementById('mime'),
          btnInit: document.getElementById('btnInit'),
          btnDisable: document.getElementById('btnDisable'),
          btnStart: document.getElementById('btnStart'),
          btnStop: document.getElementById('btnStop'),
          btnClear: document.getElementById('btnClear'),

          scope: document.getElementById('scope'),
          vizMode: document.getElementById('vizMode'),
          inPoint: document.getElementById('inPoint'),
          outPoint: document.getElementById('outPoint'),
          inLabel: document.getElementById('inLabel'),
          outLabel: document.getElementById('outLabel'),
          btnPlay: document.getElementById('btnPlay'),
          btnExportWav: document.getElementById('btnExportWav'),
          btnCut: document.getElementById('btnCut'),
          player: document.getElementById('player'),

          compat: document.getElementById('compat'),
          log: document.getElementById('log'),
        };

        // ---------- State ----------
        let stream = null;
        let mediaRecorder = null;
        let recordedChunks = [];
        let audioCtx = null;
        let sourceNode = null;
        let analyser = null;
        let rafId = null;

        let decodedBuffer = null; // AudioBuffer for editing/export
        let playbackUrl = null;
        let skipDecodeOnStop = false;

        // ---------- Utils ----------
        const log = (s) => {
          els.log.style.display = 'block';
          els.log.textContent = String(s);
        };

        const setStatus = (s) => {
          els.status.textContent = s;
        };

        const showCompat = (type, msg) => {
          els.compat.style.display = 'block';
          els.compat.className = 'msg ' + (type || 'warn');
          els.compat.textContent = msg;
        };

        const hideCompat = () => {
          els.compat.style.display = 'none';
          els.compat.textContent = '';
        };

        const clamp = (x, a, b) => Math.max(a, Math.min(b, x));

        function formatSec(sec) {
          if (!Number.isFinite(sec)) return '—';
          return sec.toFixed(2) + 's';
        }

        function getSupportedMimes() {
          const candidates = [
            'audio/webm;codecs=opus',
            'audio/webm',
            'audio/ogg;codecs=opus',
            'audio/ogg',
            'audio/mp4', // Safari sometimes
          ];
          const supported = [];
          if (!('MediaRecorder' in window)) return supported;
          for (const c of candidates) {
            try {
              if (MediaRecorder.isTypeSupported(c)) supported.push(c);
            } catch {}
          }
          // If nothing reported, allow empty (browser default)
          return supported.length ? supported : [''];
        }

        async function refreshDevices() {
          if (!navigator.mediaDevices?.enumerateDevices) {
            els.deviceSelect.innerHTML = '';
            const opt = document.createElement('option');
            opt.value = '';
            opt.textContent = 'Список устройств недоступен';
            els.deviceSelect.appendChild(opt);
            return;
          }
          const devices = await navigator.mediaDevices.enumerateDevices();
          const inputs = devices.filter((d) => d.kind === 'audioinput');
          els.deviceSelect.innerHTML = '';
          for (const d of inputs) {
            const opt = document.createElement('option');
            opt.value = d.deviceId;
            opt.textContent = d.label || `Микрофон (${d.deviceId.slice(0, 6)}…)`;
            els.deviceSelect.appendChild(opt);
          }
          if (!inputs.length) {
            const opt = document.createElement('option');
            opt.value = '';
            opt.textContent = 'Устройства не найдены';
            els.deviceSelect.appendChild(opt);
          }
        }

        function stopLiveViz() {
          if (rafId) cancelAnimationFrame(rafId);
          rafId = null;
        }

        function drawLive() {
          if (!analyser) return;
          const canvas = els.scope;
          const ctx = canvas.getContext('2d');
          const w = canvas.width,
            h = canvas.height;

          const data = new Uint8Array(analyser.fftSize);
          analyser.getByteTimeDomainData(data);

          // Background
          ctx.clearRect(0, 0, w, h);
          ctx.fillStyle = 'rgba(16,20,27,0.85)';
          ctx.fillRect(0, 0, w, h);

          // Midline
          ctx.strokeStyle = 'rgba(39,48,67,0.9)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(0, h / 2);
          ctx.lineTo(w, h / 2);
          ctx.stroke();

          // Wave
          ctx.strokeStyle = 'rgba(140,255,179,0.95)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          const slice = w / data.length;
          for (let i = 0; i < data.length; i++) {
            const v = data[i] / 128.0; // 0..2
            const y = (v * h) / 2;
            const x = i * slice;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.stroke();

          rafId = requestAnimationFrame(drawLive);
        }

        function drawStaticWave(buffer, inSec, outSec) {
          const canvas = els.scope;
          const ctx = canvas.getContext('2d');
          const w = canvas.width,
            h = canvas.height;

          ctx.clearRect(0, 0, w, h);
          ctx.fillStyle = 'rgba(16,20,27,0.85)';
          ctx.fillRect(0, 0, w, h);

          // border-ish grid
          ctx.strokeStyle = 'rgba(39,48,67,0.65)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(0, h / 2);
          ctx.lineTo(w, h / 2);
          ctx.stroke();

          if (!buffer) return;

          const ch0 = buffer.getChannelData(0);
          const len = ch0.length;

          // peaks per pixel
          const step = Math.max(1, Math.floor(len / w));
          ctx.strokeStyle = 'rgba(140,255,179,0.95)';
          ctx.lineWidth = 1;
          ctx.beginPath();

          for (let x = 0; x < w; x++) {
            const start = x * step;
            let min = 1,
              max = -1;
            for (let i = start; i < start + step && i < len; i++) {
              const v = ch0[i];
              if (v < min) min = v;
              if (v > max) max = v;
            }
            const y1 = (1 - (max + 1) / 2) * h;
            const y2 = (1 - (min + 1) / 2) * h;
            ctx.moveTo(x, y1);
            ctx.lineTo(x, y2);
          }
          ctx.stroke();

          // Selection overlay
          const dur = buffer.duration;
          const a = clamp(inSec, 0, dur);
          const b = clamp(outSec, 0, dur);
          const x1 = Math.floor((Math.min(a, b) / dur) * w);
          const x2 = Math.floor((Math.max(a, b) / dur) * w);

          ctx.fillStyle = 'rgba(255,211,107,0.18)';
          ctx.fillRect(x1, 0, Math.max(1, x2 - x1), h);

          ctx.strokeStyle = 'rgba(255,211,107,0.6)';
          ctx.lineWidth = 2;
          ctx.strokeRect(x1 + 1, 1, Math.max(1, x2 - x1) - 2, h - 2);
        }

        function updateInOutUI() {
          if (!decodedBuffer) return;
          const dur = decodedBuffer.duration;
          const inV = Number(els.inPoint.value);
          const outV = Number(els.outPoint.value);
          els.inLabel.textContent = formatSec(inV);
          els.outLabel.textContent = formatSec(outV);
          els.dur.textContent = formatSec(dur);
          drawStaticWave(decodedBuffer, inV, outV);
        }

        function resetEditedState() {
          decodedBuffer = null;
          els.player.style.display = 'none';
          if (playbackUrl) URL.revokeObjectURL(playbackUrl);
          playbackUrl = null;

          els.inPoint.disabled = true;
          els.outPoint.disabled = true;
          els.btnPlay.disabled = true;
          els.btnExportWav.disabled = true;
          els.btnCut.disabled = true;

          els.inPoint.value = 0;
          els.outPoint.value = 0;
          els.inPoint.max = 0;
          els.outPoint.max = 0;
          els.inLabel.textContent = '0.00s';
          els.outLabel.textContent = '0.00s';
          els.dur.textContent = '—';
          els.vizMode.textContent = 'live';

          // Clear canvas
          const ctx = els.scope.getContext('2d');
          ctx.clearRect(0, 0, els.scope.width, els.scope.height);
          ctx.fillStyle = 'rgba(16,20,27,0.85)';
          ctx.fillRect(0, 0, els.scope.width, els.scope.height);
        }

        function interleaveChannels(audioBuffer) {
          const numCh = audioBuffer.numberOfChannels;
          const length = audioBuffer.length;
          if (numCh === 1) return audioBuffer.getChannelData(0).slice();

          const chans = [];
          for (let c = 0; c < numCh; c++) chans.push(audioBuffer.getChannelData(c));
          const out = new Float32Array(length * numCh);
          let idx = 0;
          for (let i = 0; i < length; i++) {
            for (let c = 0; c < numCh; c++) out[idx++] = chans[c][i];
          }
          return out;
        }

        function floatTo16BitPCM(float32) {
          const out = new Int16Array(float32.length);
          for (let i = 0; i < float32.length; i++) {
            const s = clamp(float32[i], -1, 1);
            out[i] = s < 0 ? Math.round(s * 0x8000) : Math.round(s * 0x7fff);
          }
          return out;
        }

        function writeWavHeader(view, { numChannels, sampleRate, bitsPerSample, dataByteLength }) {
          const blockAlign = (numChannels * bitsPerSample) / 8;
          const byteRate = sampleRate * blockAlign;
          const riffChunkSize = 36 + dataByteLength;

          let p = 0;
          const writeStr = (s) => {
            for (let i = 0; i < s.length; i++) view.setUint8(p++, s.charCodeAt(i));
          };
          const u32 = (v) => {
            view.setUint32(p, v, true);
            p += 4;
          };
          const u16 = (v) => {
            view.setUint16(p, v, true);
            p += 2;
          };

          writeStr('RIFF');
          u32(riffChunkSize);
          writeStr('WAVE');
          writeStr('fmt ');
          u32(16); // PCM
          u16(1); // audio format = PCM
          u16(numChannels);
          u32(sampleRate);
          u32(byteRate);
          u16(blockAlign);
          u16(bitsPerSample);
          writeStr('data');
          u32(dataByteLength);
        }

        function encodeWavFromAudioBuffer(audioBuffer, { inSec, outSec } = {}) {
          const sr = audioBuffer.sampleRate;
          const numCh = audioBuffer.numberOfChannels;

          const start = Math.floor(clamp(inSec ?? 0, 0, audioBuffer.duration) * sr);
          const end = Math.floor(clamp(outSec ?? audioBuffer.duration, 0, audioBuffer.duration) * sr);
          const a = Math.min(start, end);
          const b = Math.max(start, end);
          const frameCount = Math.max(0, b - a);

          // Create a trimmed buffer in memory (Float32), interleaved
          let trimmed;
          if (numCh === 1) {
            const ch0 = audioBuffer.getChannelData(0);
            trimmed = ch0.slice(a, b);
          } else {
            // interleave after slicing each channel
            const slices = [];
            for (let c = 0; c < numCh; c++) slices.push(audioBuffer.getChannelData(c).slice(a, b));
            trimmed = new Float32Array(frameCount * numCh);
            let idx = 0;
            for (let i = 0; i < frameCount; i++) for (let c = 0; c < numCh; c++) trimmed[idx++] = slices[c][i];
          }

          const pcm16 = floatTo16BitPCM(trimmed);
          const dataBytes = pcm16.byteLength;
          const buffer = new ArrayBuffer(44 + dataBytes);
          const view = new DataView(buffer);
          writeWavHeader(view, { numChannels: numCh, sampleRate: sr, bitsPerSample: 16, dataByteLength: dataBytes });

          // Write PCM
          let offset = 44;
          for (let i = 0; i < pcm16.length; i++, offset += 2) view.setInt16(offset, pcm16[i], true);

          return new Blob([buffer], { type: 'audio/wav' });
        }

        function downloadBlob(blob, filename) {
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          a.remove();
          setTimeout(() => URL.revokeObjectURL(url), 1500);
        }

        async function decodeRecordedBlob(blob) {
          const arr = await blob.arrayBuffer();
          // Use a fresh audio context for decoding with "real" sample rate
          const ctx = new (window.AudioContext || window.webkitAudioContext)();
          const audioBuffer = await ctx.decodeAudioData(arr.slice(0));
          await ctx.close();
          return audioBuffer;
        }

        async function rebuildPlayerFromBuffer(buffer) {
          // Make a WAV for convenient preview in <audio>
          const wav = encodeWavFromAudioBuffer(buffer, { inSec: 0, outSec: buffer.duration });
          if (playbackUrl) URL.revokeObjectURL(playbackUrl);
          playbackUrl = URL.createObjectURL(wav);
          els.player.src = playbackUrl;
          els.player.style.display = 'block';
        }

        function setButtons({ initReady = false, canRecord = false, isRecording = false, hasClip = false }) {
          els.btnInit.disabled = false;
          els.btnDisable.disabled = !canRecord;
          els.btnStart.disabled = !(canRecord && !isRecording);
          els.btnStop.disabled = !isRecording;
          els.btnClear.disabled = !(canRecord || hasClip);

          els.inPoint.disabled = !hasClip;
          els.outPoint.disabled = !hasClip;
          els.btnPlay.disabled = !hasClip;
          els.btnExportWav.disabled = !hasClip;
          els.btnCut.disabled = !hasClip;
        }

        async function disableMic() {
          hideCompat();
          if (mediaRecorder && mediaRecorder.state === 'recording') {
            try {
              skipDecodeOnStop = true;
              mediaRecorder.stop();
            } catch {}
          }
          mediaRecorder = null;
          if (stream) {
            stream.getTracks().forEach((t) => t.stop());
            stream = null;
          }
          stopLiveViz();
          if (audioCtx) {
            try {
              await audioCtx.close();
            } catch {}
            audioCtx = null;
          }
          resetEditedState();
          setStatus('не инициализировано');
          setButtons({ canRecord: false, isRecording: false, hasClip: false });
        }

        async function getUserMediaWithFallback(constraints) {
          try {
            return { stream: await navigator.mediaDevices.getUserMedia(constraints), usedFallback: false };
          } catch (e) {
            const isConstraintError = e?.name === 'OverconstrainedError' || e?.name === 'ConstraintNotSatisfiedError';
            if (!isConstraintError) throw e;

            // Ослабляем требования по частоте/каналам, если устройство их не поддерживает
            const relaxed = { audio: { ...constraints.audio } };
            delete relaxed.audio.sampleRate;
            delete relaxed.audio.channelCount;
            return { stream: await navigator.mediaDevices.getUserMedia(relaxed), usedFallback: true };
          }
        }

        // ---------- Init: mime options ----------
        function populateMime() {
          const supported = getSupportedMimes();
          els.mime.innerHTML = '';
          const preferred = 'audio/webm;codecs=opus';
          supported.forEach((m) => {
            const opt = document.createElement('option');
            opt.value = m;
            opt.textContent = m ? m : '(по умолчанию браузера)';
            els.mime.appendChild(opt);
          });
          if (supported.includes(preferred)) {
            els.mime.value = preferred;
          }
        }

        // ---------- Core: mic init ----------
        async function initMic() {
          hideCompat();

          if (!navigator.mediaDevices?.getUserMedia) {
            showCompat(
              'bad',
              'Этот браузер не поддерживает getUserMedia(). Нужен современный Chrome/Edge/Firefox/Safari.',
            );
            return;
          }
          if (!('MediaRecorder' in window)) {
            showCompat('bad', 'MediaRecorder не поддерживается. В этом варианте страницы запись невозможна.');
            return;
          }

          // Stop old stream
          if (stream) {
            stream.getTracks().forEach((t) => t.stop());
            stream = null;
          }
          stopLiveViz();
          if (audioCtx) {
            try {
              await audioCtx.close();
            } catch {}
            audioCtx = null;
          }
          resetEditedState();

          const deviceId = els.deviceSelect.value || undefined;
          const preferSR = els.preferSR.value ? Number(els.preferSR.value) : undefined;
          const channelCount = Number(els.channels.value) || 1;

          const constraints = {
            audio: {
              deviceId: deviceId ? { exact: deviceId } : undefined,
              channelCount: { ideal: channelCount },
              sampleRate: preferSR ? { ideal: preferSR } : undefined,
              echoCancellation: !!els.ec.checked,
              noiseSuppression: !!els.ns.checked,
              autoGainControl: !!els.agc.checked,
            },
          };

          try {
            setStatus('запрашиваем доступ…');
            const result = await getUserMediaWithFallback(constraints);
            stream = result.stream;
            if (result.usedFallback) {
              showCompat('warn', 'Не удалось применить частоту/каналы. Используются параметры устройства.');
            }

            if (preferSR) {
              const track = stream.getAudioTracks()[0];
              const settings = track?.getSettings?.();
              const actualSR = settings?.sampleRate;
              if (actualSR && actualSR !== preferSR) {
                showCompat(
                  'warn',
                  `Запрошенная частота ${preferSR} Hz не поддерживается. Используется ${actualSR} Hz.`,
                );
              }
            }

            // Build AudioContext for live visualization
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            sourceNode = audioCtx.createMediaStreamSource(stream);
            analyser = audioCtx.createAnalyser();
            analyser.fftSize = 2048;
            sourceNode.connect(analyser);

            els.sr.textContent = String(audioCtx.sampleRate);
            els.ch.textContent = String(channelCount);

            setStatus('готово');
            els.vizMode.textContent = 'live';
            drawLive();

            // Populate device labels after permission
            await refreshDevices();

            setButtons({ canRecord: true, isRecording: false, hasClip: false });
          } catch (e) {
            console.error(e);
            setStatus('ошибка');
            showCompat(
              'bad',
              'Не удалось получить доступ к микрофону. Проверь разрешения браузера и выбранное устройство.',
            );
            log(e?.message || String(e));
            setButtons({ canRecord: false, isRecording: false, hasClip: false });
          }
        }

        // ---------- Recording ----------
        function startRecording() {
          if (!stream) return;

          recordedChunks = [];
          const mimeType = els.mime.value || undefined;

          try {
            mediaRecorder = new MediaRecorder(stream, mimeType ? { mimeType } : undefined);
          } catch (e) {
            console.error(e);
            showCompat('bad', 'Не удалось создать MediaRecorder с выбранным mimeType. Попробуй другой вариант кодека.');
            return;
          }

          mediaRecorder.ondataavailable = (ev) => {
            if (ev.data && ev.data.size > 0) recordedChunks.push(ev.data);
          };

          mediaRecorder.onerror = (ev) => {
            console.error(ev);
            showCompat('bad', 'Ошибка MediaRecorder во время записи.');
          };

          mediaRecorder.onstart = () => {
            setStatus('запись…');
            setButtons({ canRecord: true, isRecording: true, hasClip: false });
            els.vizMode.textContent = 'live';
          };

          mediaRecorder.onstop = async () => {
            if (skipDecodeOnStop) {
              skipDecodeOnStop = false;
              setStatus(stream ? 'готово' : 'не инициализировано');
              setButtons({ canRecord: !!stream, isRecording: false, hasClip: false });
              if (analyser) drawLive();
              return;
            }

            setStatus('обработка…');
            setButtons({ canRecord: true, isRecording: false, hasClip: false });
            stopLiveViz();

            const blob = new Blob(recordedChunks, { type: mediaRecorder.mimeType || 'audio/webm' });

            try {
              decodedBuffer = await decodeRecordedBlob(blob);

              // UI setup for edit
              const dur = decodedBuffer.duration;
              els.inPoint.max = String(dur);
              els.outPoint.max = String(dur);
              els.inPoint.value = '0';
              els.outPoint.value = String(dur);

              els.sr.textContent = String(decodedBuffer.sampleRate);
              els.ch.textContent = String(decodedBuffer.numberOfChannels);
              els.dur.textContent = formatSec(dur);

              els.vizMode.textContent = 'static';
              updateInOutUI();

              await rebuildPlayerFromBuffer(decodedBuffer);

              setStatus('готово (клип загружен)');
              setButtons({ canRecord: true, isRecording: false, hasClip: true });
            } catch (e) {
              console.error(e);
              setStatus('ошибка');
              showCompat(
                'bad',
                'Не удалось декодировать запись для редактирования. Попробуй другой кодек или другой браузер.',
              );
              log(e?.message || String(e));
              setButtons({ canRecord: true, isRecording: false, hasClip: false });
              // restore live visualization
              if (analyser) drawLive();
            }
          };

          try {
            mediaRecorder.start(250); // chunk every 250ms
          } catch (e) {
            console.error(e);
            showCompat('bad', 'Не удалось стартовать запись.');
            log(e?.message || String(e));
          }
        }

        function stopRecording() {
          if (!mediaRecorder) return;
          if (mediaRecorder.state === 'recording') mediaRecorder.stop();
        }

        // ---------- Editing: trim/cut ----------
        async function playTrim() {
          if (!decodedBuffer) return;
          const inSec = Number(els.inPoint.value);
          const outSec = Number(els.outPoint.value);
          const a = Math.min(inSec, outSec);
          const b = Math.max(inSec, outSec);

          // Make WAV for preview of trimmed section
          const wav = encodeWavFromAudioBuffer(decodedBuffer, { inSec: a, outSec: b });
          if (playbackUrl) URL.revokeObjectURL(playbackUrl);
          playbackUrl = URL.createObjectURL(wav);
          els.player.src = playbackUrl;
          els.player.style.display = 'block';
          await els.player.play().catch(() => {});
        }

        async function cutSelectionAndReplace() {
          if (!decodedBuffer) return;

          const sr = decodedBuffer.sampleRate;
          const numCh = decodedBuffer.numberOfChannels;
          const inSec = Number(els.inPoint.value);
          const outSec = Number(els.outPoint.value);
          const a = Math.min(inSec, outSec);
          const b = Math.max(inSec, outSec);

          const start = Math.floor(clamp(a, 0, decodedBuffer.duration) * sr);
          const end = Math.floor(clamp(b, 0, decodedBuffer.duration) * sr);

          if (end <= start) return;

          const newLength = decodedBuffer.length - (end - start);
          if (newLength <= 0) {
            showCompat('warn', 'Нельзя удалить весь клип целиком. Выдели меньший диапазон.');
            return;
          }
          hideCompat();

          // Create new AudioBuffer
          const ctx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: sr });
          const outBuf = ctx.createBuffer(numCh, newLength, sr);

          for (let c = 0; c < numCh; c++) {
            const src = decodedBuffer.getChannelData(c);
            const dst = outBuf.getChannelData(c);

            // copy [0..start)
            dst.set(src.slice(0, start), 0);

            // copy [end..]
            dst.set(src.slice(end), start);
          }

          decodedBuffer = outBuf;

          const dur = decodedBuffer.duration;
          els.inPoint.max = String(dur);
          els.outPoint.max = String(dur);
          els.inPoint.value = '0';
          els.outPoint.value = String(dur);

          els.dur.textContent = formatSec(dur);
          els.vizMode.textContent = 'static';
          updateInOutUI();
          await rebuildPlayerFromBuffer(decodedBuffer);

          // close temp ctx
          try {
            await ctx.close();
          } catch {}
        }

        // ---------- Wire UI ----------
        populateMime();

        // Initial device list (labels may be empty before permission)
        if (navigator.mediaDevices?.enumerateDevices) {
          refreshDevices().catch(() => {});
        }

        els.btnInit.addEventListener('click', initMic);
        els.btnDisable.addEventListener('click', disableMic);
        els.btnStart.addEventListener('click', startRecording);
        els.btnStop.addEventListener('click', stopRecording);

        els.btnClear.addEventListener('click', async () => {
          hideCompat();
          resetEditedState();
          recordedChunks = [];
          if (mediaRecorder && mediaRecorder.state === 'recording') {
            try {
              skipDecodeOnStop = true;
              mediaRecorder.stop();
            } catch {}
          }
          mediaRecorder = null;
          setStatus(stream ? 'готово' : 'не инициализировано');
          if (analyser) drawLive();
          setButtons({ canRecord: !!stream, isRecording: false, hasClip: false });
        });

        els.inPoint.addEventListener('input', updateInOutUI);
        els.outPoint.addEventListener('input', updateInOutUI);

        els.btnPlay.addEventListener('click', playTrim);

        els.btnExportWav.addEventListener('click', () => {
          if (!decodedBuffer) return;
          const inSec = Number(els.inPoint.value);
          const outSec = Number(els.outPoint.value);
          const a = Math.min(inSec, outSec);
          const b = Math.max(inSec, outSec);

          const wav = encodeWavFromAudioBuffer(decodedBuffer, { inSec: a, outSec: b });
          const ts = new Date().toISOString().replaceAll(':', '-').slice(0, 19);
          downloadBlob(wav, `recording_${ts}_${Math.round((b - a) * 100) / 100}s.wav`);
        });

        els.btnCut.addEventListener('click', cutSelectionAndReplace);

        // React to device changes (re-init required)
        els.deviceSelect.addEventListener('change', () => {
          if (stream) {
            showCompat(
              'warn',
              'Устройство изменено. Нажми "Инициализировать микрофон" ещё раз, чтобы применить выбор.',
            );
          }
        });

        // If devices change while page is open
        navigator.mediaDevices?.addEventListener?.('devicechange', () => {
          refreshDevices().catch(() => {});
        });

        // Compatibility hints
        if (!('MediaRecorder' in window)) {
          showCompat('bad', 'MediaRecorder не поддерживается в этом браузере. Попробуй Chrome/Edge/Firefox.');
          setStatus('несовместимо');
        } else {
          setStatus('не инициализировано');
        }
      })();
    </script>
  </body>
</html>
